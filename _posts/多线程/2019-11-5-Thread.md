---
layout:     post
title:      多线程原理
subtitle:    "\" 多线程的本质及概要\""
date:       2019-11-5
author:     Jim
header-img: ../../img/多线程/thread.png
catalog: true
tags:
    - 多线程
---


## 前言
天天喊多线程高并发，今天咱们就来彻底搞搞这个多线程，看看在Java的世界里，多线程到底是个啥
<p id = "build"></p>
---

## 正文
任何东西的出现都是为了解决没有它的时候所面临的的问题<br>
所以这里先抛出几个问题<br>
###为什么使用多线程：<br>
    ①CPU/内存/硬盘巨大的IO时间差异<br>
    CPU的时钟周期:<br>
        时钟周期也称为振荡周期，定义为时钟频率的倒数。
        时钟周期是计算机中最基本的、最小的时间单位。
        在一个时钟周期内，CPU仅完成一个最基本的动作。
        时钟周期是一个时间的量。时钟周期表示了SDRAM所能运行的最高频率。
        更小的时钟周期就意味着更高的工作频率 ----摘自Wiki<br>
        举例 某CPU的频率为：3GHz  ==》三十亿次/秒 大概换算一下也就是说:<br>
        CPU的一个时钟周期大概花费10-9秒，而一次内存读取呢？大概10-6秒，硬盘IO呢？大概10-4秒<br>
        可见CPU是忍受不了这样巨大的IO时间差异的，CPU和硬盘甚至相差了5个数量级接近百万倍！<br>
        举个例子：如果等价于现实生活中，CPU阿甘问硬盘老大哥：硬盘大哥您吃晚饭了吗？<br>
        假设CPU阿甘说这话花了1S，那么百万秒之后（一天大概八万秒），也就是大概12天后：<br>
        硬盘大哥回复：阿甘兄弟，我吃完晚饭了呀。<br>
        不知道此时已经吃完12天早中午晚饭的阿甘兄弟怎么想。。
               
	②多核CPU的出现<br>
	现在的CPU上不止集成了一个核心，
	可以将一个核心理解为一个CPU<br>
	也就是说现在个人PC或移动计算设备都是多CPU，为了充分的发挥CPU的计算能力，诞生出了多线程<br>
	这里再强调一下：<br>
	对于IO密集型的工作，多线程充分利用了CPU闲置时间的计算力，无疑提高了整个系统的性能<br>
	而对于CPU密集型的工作，过多的线程导致频繁的线程上下文切换（一次上下文切换大概花费3000个时钟周期，相当于这3000个时钟周期白白被浪费）
	，这样反而会降低系统的性能。所以应该权衡考虑（下面会提到一种类似多线程的方式：协程<br>
	线程的本质：每个线程相当于可以干活的工人（每个人都可以响应具体的工作）<br>
	
###协程：
    为了解决在多线程里CPU频繁的上下文线程切换所耗费的时钟周期，
    能不能我让这个线程一直占据着CPU时间没有上下文切换且同时我在这个线程内部再实现类似于‘多线程’的功能 --协程就诞生了（协程最佳实践者--Go）<br>
    
    优点：
        快：始终占有CPU，在用户态
        小：可以方便的实现上百万的并发度
    解决的问题：
        多线程调度较慢，占有资源多的问题
    不解决的问题：
    	并发问题:死锁/竞争条件


###Thread到底是什么
    只有Thread类的每一个实例才代表一个JVM中的线程，其它的都不是线程
    每当调用Thread.start JVM就增加一套方法栈
    启动一个线程栈只能通过这两种方法进入：
    xxx.main/Thread.run()  （可以debug查看每个线程栈帧内位于栈底的方法）
 ####Thread的内存模型
	每一个线程对应linux上叫轻量级进程task（独立PID）（只不过多个task共享一块内存）
	优点：
    	简单，直接依赖OS的调度器实现
    缺点：
    	占用资源特别多
    	上下文切换慢
    	不灵活，无法实现灵活的优先级[依赖于OS的线程调度]
 ####Thread的生命周期：
      	New(创建)
      	Runnable(可能在等待，可能正在执行，也可能正在阻塞[IO])
      	Blocked（锁状态）
      	Waiting（等待锁）
 ####ThreadLocal:
     每个线程私有的数据
     场景：用于全局存储线程私有变量
###线程栈里每一个方法栈帧里边都有什么？
    *（执行字节码所需要的信息）
    局部变量表
    操作数栈