---
layout:     post
title:      JUC
subtitle:    "\" JUC包、Fork/Join与并发流\""
date:       2019-11-14
author:     Jim
header-img: ../../img/多线程/juc.png
catalog: true
tags:
    - 多线程
---
上一节我们探讨了为什么要使用多线程，以及多线程会出现的问题:<br>
1.## 同步问题(数据)<br>
2.## 协作问题(同步)<br>
解决方案:<br>
 ### 1.同步：<br>
   ####①Synchronized(同步，获得互斥锁):任何一个对象都可以当锁，用在方法和方法块前 <br>
   缺点：Synchronized锁比较重量，效率低。jdk老版本基本都是直接加Synchronized实现同步。Synchronized属于悲观锁的一种实现。<br>
        *无锁<br>
        *偏向锁:Java偏向锁(Biased Locking)是Java6引入的一项多线程优化。
             偏向锁，顾名思义，它会偏向于第一个访问锁的线程，如果在运行过程中，同步锁只有一个线程访问，不存在多线程争用的情况，则线程是不需要触发同步的，这种情况下，就会给线程加一个偏向锁。
             如果在运行过程中，遇到了其他线程抢占锁，则持有偏向锁的线程会被挂起，JVM会消除它身上的偏向锁，将锁恢复到标准的轻量级锁。
             <br>
        *轻量锁:轻量级锁是由偏向所升级来的，偏向锁运行在一个线程进入同步块的情况下，当第二个线程加入锁争用的时候，偏向锁就会升级为轻量级锁<br>
        *重量锁：Synchronized<br>
        **锁粗化**：大部分情况下我们是要让锁的粒度最小化，锁的粗化则是要增大锁的粒度
            在以下场景下需要粗化锁的粒度：
            假如有一个循环，循环内的操作需要加锁，我们应该把锁放到循环外面，否则每次进出循环，都进出一次临界区，效率是非常差的<br>
        使用读写锁:ReentrantReadWriteLock 是一个读写锁，读操作加读锁，可以并发读，写操作使用写锁，只能单线程写<br>
        **锁消除**:锁消除是发生在编译器级别的一种锁优化方式。
          有时候我们写的代码完全不需要加锁，却执行了加锁操作。
   ####②**CAS**(Compare And Swap)：
   不使用锁，改变共享变量后，去和原来的值比较一下，如果原来的值已经不是当时自己拿出来的那个值，则一直while()循环执行当前操作，
   直到操作成功<br>
        **缺点**：ABA问题(已经被其它线程执行过，只不过还是原来的值)-->解决ABA问题：加版本（时间）戳。CAS属于乐观锁的典型实现。<br>
        
        
 ### 2.协作：<br>
   #####含义：让线程听指挥按需顺序执行。本质：-->放弃CPU占用权限，中断唤醒。<br>
   #####生产者消费者模型<br>
   ####①Java原生：wait(),notify(),notifyAll(),(Object类下)<br>
   ####②JUC


